<snippet>
  <content><![CDATA[
<res label="rate_show_score_text">%s <b>(%s점)</b></res>
<res label="rank_order_err">점수가 높은 순서로 응답 부탁드립니다.</res>
<exec when="init">
def rate_show_score(scale_qid, rank_qid) :
  for row in rank_qid.rows :
    if scale_qid.attr(row.label).any :
      row.text = res.rate_show_score_text%(scale_qid.attr(row.label).text, scale_qid.cols[scale_qid.attr(row.label).val].value)

def scale_rank_items(scale_qid, rank_qid, reverse=True) :
    if gv.isSST() :
      return {
          'show' : [x.label for x in rank_qid.rows],
          'skip' : False,
          'auto' : []
        }
    scale_answer = {x.label: x.val for x in scale_qid.rows.order if x.any}
    sorted_list = sorted(scale_answer.items(), key=lambda item: item[1], reverse=reverse)
    
    rank_cols = [each for each in rank_qid.cols]
    if not reverse :
      rank_cols.reverse()
 
    sort_rows = []
    current_value = None
    current_group = []
 
    for item in sorted_list:
        key, value = item
        if value != current_value:
            if current_group: 
                sort_rows.append(current_group)
            current_group = [key]
            current_value = value
        else:
            current_group.append(key)
 
    if current_group:
        sort_rows.append(current_group)
 
    rank_able_answer = []
    rank_auto_row = {}
    rowCond = []
    for idx, eachCol in enumerate(rank_cols) :
      if idx ge len(sort_rows) : 
        continue
      row_label = sort_rows[idx]
      rank_able_answer.append(row_label)
 
      if len(rowCond) ge len(rank_cols) :
        continue
 
      for x in row_label :
        rowCond.append(x)
 
    rank_qid.rows.order = [scale_qid.attr(each).index for each in sum(sort_rows, [])]
 
    skip_cond = all(len(row)==1 for row in rank_able_answer)
    print(rank_able_answer)
    print(rowCond)
 
    auto_rows = []
    for idx, row_list in enumerate(rank_able_answer) :
      if len(row_list) == 1 :
        auto_rows.append([idx+1, row_list[0]])
        if not gv.isSST() :
          rank_qid.cols[idx].val = rank_qid.attr(row_list[0]).index
      else :
        break
 
    return {
      'show' : rowCond,
      'skip' : skip_cond,
      'auto' : auto_rows
    }

def scale_rank_vali(scale_qid) :
  if gv.isSST() :
    return
  for idx, eachCol in enumerate(this.cols) :
    if idx == (len(this.cols)-1) :
      continue
 
    curr = eachCol
    next = this.cols[idx+1]
 
    curr_value = scale_qid.rows[curr.val].val
    next_value = scale_qid.rows[next.val].val
 
    if next_value gt curr_value :
      for x in [curr, next] :
        error(res.rank_order_err, col=x)
</exec>
]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>scale.rank.def</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>text.xml</scope>
</snippet>
